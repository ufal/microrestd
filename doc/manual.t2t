MicroRestD
Version 0.9.0-devel

= Introduction =

%!include: readme.t2t


= MicroRestD Operations =

MicroRestD provides a simple REST server. The server supports HEAD, GET,
POST, PUT and DELETE methods and automatic parsing of query strings
and POST ``application/x-www-form-urlencoded`` and ``multipart/form-data``
request bodies.

Linux, OS X and Windows systems are supported, although the support on Windows
is not full-fledged. Only ``select`` is supported on Windows compared to
``poll`` on Linux and OS X and there is no support for native Windows service.
Also, on Linux and OS X there is support for seamless service restart (starting
a second service, draining the first one and stopping it after all its requests
are processed), which is not available on Windows because signals are used to
indicate the restart. Nevertheless, all of these shortcomings could be sorted
out if there is need for it.

Each request is processed by a new thread by default, but it is possible to use
a thread pool. Classes for generating JSON and XML responses are provided.
Responses can be generated progressively, so multiple responses can be
processed simultaneously by one thread.

Internally, [libmicrohttpd http://www.gnu.org/software/libmicrohttpd/] is used
as a HTTP server. Also [pugixml http://pugixml.org/] is provided for XML
parsing and manupulation.


= MicroRestD API Reference =

The MicroRestD library is contained in ``ufal::microrestd`` namespace,
including both [libmicrohttpd http://www.gnu.org/software/libmicrohttpd/]
and [pugixml http://pugixml.org/] libraries.

The MicroRestD API is available through the ``microrestd.h`` header.
To compile MicroRestD, include the ``Makefile.include`` makefile, compile
the sources listed in ``MICRORESTD_OBJECTS`` variable and link the
libraries listed in either ``MICRORESTD_LIBRARIES_POSIX`` or
``MICRORESTD_LIBRARIES_WIN`` depending on the operating system.

== Structure string_piece ==[string_piece]
```
struct string_piece {
  const char* str;
  size_t len;

  string_piece();
  string_piece(const char* str);
  string_piece(const char* str, size_t len);
  string_piece(const std::string& str);
}
```

The [``string_piece`` #string_piece] is used for efficient string passing. The string
referenced in [``string_piece`` #string_piece] is not owned by it, so users have to make sure
the referenced string exists as long as the [``string_piece`` #string_piece].

== Class response_generator ==[response_generator]
```
class response_generator {
 public:
  virtual ~response_generator() {}

  virtual bool [generate #response_generator_generate]() = 0;
  virtual [string_piece #string_piece] [current #response_generator_current]() const = 0;
  virtual void [consume #response_generator_consume](size_t length) = 0;
};
```

The [``response_generator`` #response_generator] abstract class defines an
interface of progressive response generator.

=== response_generator::generate ===[response_generator_generate]
``` virtual bool generate() = 0;

Try generating more response data. Returns ``false`` if there are no more data
to be generated and the end of the response has been reached. It is guaranteed
[``generate`` #generate] is never called again after returning ``false``.

=== response_generator::current ===[response_generator_current]
``` virtual [string_piece #string_piece] current() const = 0;

Return current response data.

=== response_generator::consume ===[response_generator_consume]
``` virtual void consume(size_t length) = 0;

Drop first ``length`` chars of the response data.

Note that when [``consume`` #response_generator_consume] is called, it is
guaranteed that ``length >= [current #response_generator_current]().len / 2``
so amortized cost of all calls to [``consume`` #response_generator_consume] is
at most linear in the response size.


== Class rest_request ==[rest_request]
```
class rest_request {
 public:
  virtual ~rest_request() {}

  virtual bool [respond #rest_request_respond_string_piece](const char* content_type, [string_piece #string_piece] body, bool make_copy = true) = 0;
  virtual bool [respond #rest_request_respond_generator](const char* content_type, [response_generator #response_generator]* generator) = 0;
  virtual bool [respond_not_found #rest_request_respond_not_found]() = 0;
  virtual bool [respond_method_not_allowed #rest_request_respond_method_not_allowed](const char* comma_separated_allowed_methods) = 0;
  virtual bool [respond_error #rest_request_respond_error]([string_piece #string_piece] error, int code = 400) = 0;

  std::string url;
  std::string method;
  std::string body;
  std::string content_type;
  std::unordered_map<std::string, std::string> params;
};
```

The [``rest_request`` #rest_request] class represents REST request and provides
means of responding to it.

The following variables are provided:
- ``url``
- ``method``
- ``body``, possibly empty
- ``content_type`` of body, possibly empty
- ``params``, the GET and POST parameters of the request


=== rest_request::respond with string_piece ===[rest_request_respond_string_piece]
``` virtual bool respond(const char* content_type, [string_piece #string_piece] body, bool make_copy = true) = 0;

Respond HTTP OK response with specified ``content_type`` and ``body``.

If ``make_copy`` is ``true``, a copy of ``body`` is made, otherwise it is not. Note that the response can be
sent at any later time, even after the ``rest_request`` is destroyed.

=== rest_request::respond with response_generator ===[rest_request_respond_generator]
``` virtual bool respond(const char* content_type, [response_generator #response_generator]* generator) = 0;

Respond HTTP OK response with specified ``content_type`` using the given [``response_generator`` #response_generator].

=== rest_request::respond_not_found ===[rest_request_respond_not_found]
``` virtual bool respond_not_found() = 0;

Respond HTTP Not Found.

=== rest_request::respond_method_not_allowed ===[rest_request_respond_method_not_allowed]
``` virtual bool respond_method_not_allowed(const char* comma_separated_allowed_methods) = 0;

Respond HTTP Method Not Allowed with supplied list of allowed methods.

=== rest_request::respond_error ===[rest_request_respond_error]
``` virtual bool respond_error([string_piece #string_piece] error, int code = 400) = 0;

Respond with specified HTTP code, ``text/plain`` content-type and specified error body.

If ``make_copy`` is ``true``, a copy of ``error`` is made, otherwise it is not. Note that the response can be
sent at any later time, even after the ``rest_request`` is destroyed.

== Class rest_service ==[rest_service]
```
class rest_service {
 public:
  virtual bool [handle #rest_service_handle]([rest_request #rest_request]& req) = 0;
};
```

The [``rest_service`` #rest_service] represents an interface of a REST service.

=== rest_service::handle ===[rest_service_handle]
``` virtual bool handle([rest_request #rest_request]& req) = 0;

Handle the given [``rest_request`` #rest_request]. The return code should be the one returned by
the [``rest_request`` #rest_request]::respond* methods.

== Class rest_server ==[rest_server]
```
class rest_server {
 public:
  void [set_log_file #rest_server_set_log_file](FILE* log_file, unsigned max_log_size = 0);
  void [set_min_generated #rest_server_set_min_generated](unsigned min_generated);
  void [set_max_connections #rest_server_set_max_connections](unsigned max_connections);
  void [set_max_request_body_size #rest_server_set_max_request_body_size](unsigned max_request_body_size);
  void [set_threads #rest_server_set_threads](unsigned threads);
  void [set_timeout #rest_server_set_timeout](unsigned timeout);

  bool [start #rest_server_start]([rest_service #rest_service]* service, unsigned port);
  void [stop #rest_server_stop]();
  bool [wait_until_signalled #rest_server_wait_until_signalled]();
};
```

Main REST server class.

=== rest_server::set_log_file ===[rest_server_set_log_file]
``` void set_log_file(FILE* log_file, unsigned max_log_size);

Log to the specified ``log_file``. If ``nullptr`` is passed, logging is disabled.
Note that the [``rest_server`` #rest_server] does not close ``log_file`` on exit.

If ``max_log_size`` is nonzero, it limits the size of every logged request parameter.

By default, logging is disabled.

=== rest_server::set_min_generated ===[rest_server_set_min_generated]
``` void set_min_generated(unsigned min_generated);

When a [``response_generator`` #response_generator] is used, ``min_generated``
specifies minimum buffer size which is sent (i.e. [``generate`` #response_generator_generate]
is called until this many chars are produced).

Note that maximum buffer size is limited to 32kB, so reasonable maximum for
``min_generated`` is something like 24kB.

Default value of ``min_generated`` is 1kB.

=== rest_server::set_max_connections ===[rest_server_set_max_connections]
``` void set_max_connections(unsigned max_connections);

Limit number of maximum concurrent connections (with 0 denoting unlimited number
of connections). When this limit is reached, no more connections are accepted until
some existing requests are handled.

Default value of ``max_connections`` is 0 (i.e. unlimited).

=== rest_server::set_max_request_body_size ===[rest_server_set_max_request_body_size]
``` void set_max_request_body_size(unsigned max_request_body_size);

Limit the maximum request body size (with 0 denoting no size limit).

Default value of ``max_request_body_size`` is 0 (i.e. unlimited).

=== rest_server::set_threads ===[rest_server_set_threads]
``` void set_threads(unsigned threads);

Set number of concurrently running REST server threads. If the value 0 is used,
there is one listening thread and each request is handled by a new thread.
If a nonzero value //t// is used, there are //t// threads each listening and
processing its connections (the ``max_connections`` limit is divided equally
among them in this case).

Default value of ``threads`` is 0 (i.e. each request gets a new thread).

=== rest_server::set_timeout ===[rest_server_set_timeout]
``` void set_timeout(unsigned timeout);

Set inactivity timeout in seconds (with 0 denoting no time limit).

Default value of ``timeout`` is 0 (i.e. no timeout).

=== rest_server::start ===[rest_server_start]
``` bool start([rest_service #rest_service]* service, unsigned port);

Try starting the specified [``rest_service`` #rest_service] on specified ``port``.
If the service was successfully started, ``true`` is returned, ``false`` otherwise.
The service is started in a background thread(s), so the calling thread can
continue operating.

That the socket is opened with ``SO_REUSEPORT`` on POSIX systems (and with
``SO_REUSEADDR`` on Windows which is roughly equivalent), so multiple services
can be bound to the same port.

Note the server does not take ownership of the ``service``.

=== rest_server::stop ===[rest_server_stop]
``` void stop();

Stop running REST server. No more connections are accepted, but current connections
are handled before returning.

=== rest_server::wait_until_signalled ===[rest_server_wait_until_signalled]
``` bool wait_until_signalled();

Wait until shutdown/restart is signalled. Returns ``false`` on error and ``true``
if shutdown/restart was signalled.

On POSIX systems, receiving either ``SIGUSR1`` signal or ``SIGINT`` (Ctrl+C)
signal is used to indicate shutdown/restart.  On Windows, console control
handler receiving Ctrl+C is used.

== Class json_builder ==[json_builder]
```
class json_builder {
 public:
  // Clear
  inline [json_builder #json_builder]& [clear #json_builder_clear]();

  // Encode
  inline [json_builder #json_builder]& [object #json_builder_object]();
  inline [json_builder #json_builder]& [array #json_builder_array]();
  inline [json_builder #json_builder]& [key #json_builder_key]([string_piece #string_piece] str);
  inline [json_builder #json_builder]& [value #json_builder_value]([string_piece #string_piece] str, bool append = false);
  inline [json_builder #json_builder]& [value_xml_escape #json_builder_value_xml_escape]([string_piece #string_piece] str, bool append = false);
  inline [json_builder #json_builder]& [close #json_builder_close]();
  inline [json_builder #json_builder]& [indent #json_builder_indent]();

  // Return current json
  inline [string_piece #string_piece] [current #json_builder_current]() const;

  // Remove current json prefix; for response_generator
  void [discard_current_prefix #json_builder_discard_current_prefix](size_t length);

  // JSON mime
  static const char* mime;
};
```
=== json_builder::clear ===[json_builder_clear]
``` inline [json_builder #json_builder]& clear();

=== json_builder::object ===[json_builder_object]
``` inline [json_builder #json_builder]& object();

=== json_builder::array ===[json_builder_array]
``` inline [json_builder #json_builder]& array();

=== json_builder::key ===[json_builder_key]
``` inline [json_builder #json_builder]& key([string_piece #string_piece] str);

=== json_builder::value ===[json_builder_value]
``` inline [json_builder #json_builder]& value([string_piece #string_piece] str, bool append = false);

=== json_builder::value_xml_escape ===[json_builder_value_xml_escape]
``` inline [json_builder #json_builder]& value_xml_escape([string_piece #string_piece] str, bool append = false);

=== json_builder::close ===[json_builder_close]
``` inline [json_builder #json_builder]& close();

=== json_builder::indent ===[json_builder_indent]
``` inline [json_builder #json_builder]& indent();

=== json_builder::current ===[json_builder_current]
``` inline [string_piece #string_piece] current() const;

=== json_builder::discard_current_prefix ===[json_builder_discard_current_prefix]
``` void discard_current_prefix(size_t length);


== Class json_response_generator ==[json_response_generator]
```
class json_response_generator : public [response_generator #response_generator] {
 public:
  virtual [string_piece #string_piece] current() const override;
  virtual void consume(size_t length) override;

  [json_builder #json_builder] json;
};
```

== Class xml_builder ==[xml_builder]
```
// Declarations
class xml_builder {
 public:
  // Clear
  inline xml_builder& [clear #xml_builder_clear]();

  // XML declaration
  [xml_builder #xml_builder]& [declaration #xml_builder_declaration](const char* encoding = nullptr, const char* standalone = nullptr);

  // Encode
  inline [xml_builder #xml_builder]& [element #xml_builder_element]([string_piece #string_piece] name);
  inline [xml_builder #xml_builder]& [attribute #xml_builder_attribute]([string_piece #string_piece] name, [string_piece #string_piece] value);
  inline [xml_builder #xml_builder]& [text #xml_builder_text]([string_piece #string_piece] str);
  inline [xml_builder #xml_builder]& [close #xml_builder_close]();
  inline [xml_builder #xml_builder]& [indent #xml_builder_indent]();

  // Return current xml
  inline [string_piece #string_piece] [current #xml_builder_current]() const;

  // Remove current xml prefix; for response_generator
  void [discard_current_prefix #xml_builder_discard_current_prefix](size_t length);

  // XML mime
  static const char* mime;
};
```
=== xml_builder::clear ===[xml_builder_clear]
``` inline xml_builder& clear();

=== xml_builder::declaration ===[xml_builder_declaration]
``` [xml_builder #xml_builder]& declaration(const char* encoding = nullptr, const char* standalone = nullptr);

=== xml_builder::element ===[xml_builder_element]
``` inline [xml_builder #xml_builder]& element([string_piece #string_piece] name);

=== xml_builder::attribute ===[xml_builder_attribute]
``` inline [xml_builder #xml_builder]& attribute([string_piece #string_piece] name, [string_piece #string_piece] value);

=== xml_builder::text ===[xml_builder_text]
``` inline [xml_builder #xml_builder]& text([string_piece #string_piece] str);

=== xml_builder::close ===[xml_builder_close]
``` inline [xml_builder #xml_builder]& close();

=== xml_builder::indent ===[xml_builder_indent]
``` inline [xml_builder #xml_builder]& indent();

=== xml_builder::current ===[xml_builder_current]
``` inline [string_piece #string_piece] current() const;

=== xml_builder::discard_current_prefix ===[xml_builder_discard_current_prefix]
``` void discard_current_prefix(size_t length);


== Class xml_response_generator ==[xml_response_generator]
```
class xml_response_generator : public [response_generator #response_generator] {
 public:
  virtual [string_piece #string_piece] current() const override;
  virtual void consume(size_t length) override;

  [xml_builder #xml_builder] xml;
};
```

== Structure version ==[version]
```
struct version {
  unsigned major;
  unsigned minor;
  unsigned patch;
  std::string prerelease;

  // Returns current version.
  static [version #version] [current #version_current]();
};
```

The [``version`` #version] class represents MicroRestD version
according to [Semantic Versioning http://semver.org/].

=== version::current ===[version_current]
``` static [version #version] current();

Returns current MicroRestD version.

= Pugixml =

The [pugixml http://pugixml.org/] library 1.5 is available through the
``pugixml.h`` header. The source files ``MICRORESTD_PUGIXML_OBJECTS`` must be
compiled in order to use the library.

Note that there are some minor modifications to the original [pugixml http://pugixml.org/] library:
- The library is available in ``ufal::microrestd::pugixml`` namespace instead of the original ``pugixml``.
- STL and XPATH modules of the original library are not available.
- The element and attribute matching ignores any XML namespaces used.
